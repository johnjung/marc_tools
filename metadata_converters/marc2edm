#!/usr/bin/env python
"""Usage:
    marc2dc --socscimaps
"""

import getpass
import hashlib
import os
import paramiko
import pathlib
import shutil
import subprocess
import tempfile
import sys
import xml.etree.ElementTree as ElementTree
from classes import SocSciMapsMarcXmlToEDM
from docopt import docopt

USE_SSH = False

if __name__ == "__main__":
    options = docopt(__doc__)

    if options['--socscimaps']:
        if USE_SSH:
            ssh = paramiko.SSHClient()
            ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            ssh.connect('s3.lib.uchicago.edu', username=getpass.getuser())
            ftp = ssh.open_sftp()

        collection = ElementTree.fromstring(sys.stdin.read())

        # HACK: make the 856u match paths on disk. 
        _856u = collection.find('/'.join((
            '{http://www.loc.gov/MARC21/slim}record',
            '{http://www.loc.gov/MARC21/slim}datafield[@tag="856"]',
            '{http://www.loc.gov/MARC21/slim}subfield[@code="u"]'
        )))
        _856u.text = _856u.text.replace('/maps/chisoc/', '/social_scientists_maps/')

        for record in collection.findall('{http://www.loc.gov/MARC21/slim}record'):
	        # get the identifier from the catalog record. Build paths to the
	        # master file on remote and local drives. 
            identifier = record.find('/'.join([
                '{http://www.loc.gov/MARC21/slim}datafield[@tag="856"]',
                '{http://www.loc.gov/MARC21/slim}subfield[@code="u"]'
            ])).text.split('/').pop()
            remote_tiff_path = '/'.join([
		'',
                'data',
                'voldemort',
                'digital_collections',
                'data',
		'ldr_oc_admin',
                'files',
                'IIIF_Files',
		'social_scientists_maps',
                identifier,
                'tifs',
                '{0}.tif'.format(identifier)
            ])
            local_tiff_path = os.path.join(
                tempfile.gettempdir(),
                '{}.tif'.format(identifier)
            )

            # download the file, only if necessary.
            if not os.path.exists(local_tiff_path):
                if USE_SSH:
                    ftp.get(remote_tiff_path, local_tiff_path)
                else:
                    shutil.copyfile('tifs/{}.tif'.format(identifier), local_tiff_path)

            # get technical metadata from JHOVE.
            try:
                result = subprocess.run([
                    "{}/jhove/jhove".format(pathlib.Path.home()),
                    "-h",
                    "xml",
                    local_tiff_path
                ], capture_output=True)
            except FileNotFoundError:
                sys.stderr.write('Be sure JHOVE is installed and available in your homedir at ~/jhove/jhove.\n')
                sys.exit()
            jhove = ElementTree.fromstring(result.stdout.decode('utf-8'))
            mix = jhove.find('.//{http://www.loc.gov/mix/v20}mix')

            # mimetype
            mime_type = mix.find('/'.join([
                '{http://www.loc.gov/mix/v20}BasicDigitalObjectInformation',
                '{http://www.loc.gov/mix/v20}FormatDesignation',
                '{http://www.loc.gov/mix/v20}formatName' 
            ])).text

            # size in bytes
            size = int(jhove.find('/'.join([
                '{http://schema.openpreservation.org/ois/xml/ns/jhove}repInfo',
                '{http://schema.openpreservation.org/ois/xml/ns/jhove}size'
            ])).text)

            # width in pixels.
            width = int(mix.find('/'.join([
                '{http://www.loc.gov/mix/v20}BasicImageInformation',
                '{http://www.loc.gov/mix/v20}BasicImageCharacteristics',
                '{http://www.loc.gov/mix/v20}imageWidth'
            ])).text)

            # height in pixels.
            height = int(mix.find('/'.join([
                '{http://www.loc.gov/mix/v20}BasicImageInformation',
                '{http://www.loc.gov/mix/v20}BasicImageCharacteristics',
                '{http://www.loc.gov/mix/v20}imageHeight'
            ])).text)

            # md5, sha256
            with open(local_tiff_path, 'rb') as f:
                tiff_contents = f.read()
                md5 = hashlib.md5(tiff_contents).hexdigest()
                sha256 = hashlib.sha256(tiff_contents).hexdigest()
   
            edm = SocSciMapsMarcXmlToEDM(
                '<collection>{}</collection>'.format(
                    ElementTree.tostring(record, 'utf-8', method='xml').decode('utf-8')
                ),
                [{
                    'height': height,
                    'md5': md5,
                    'mime_type': mime_type,
                    'name': '{}.tif'.format(identifier),
                    'path': remote_tiff_path,
                    'sha256': sha256,
                    'size': size,
                    'width': width
                }]
            )

            edm.build_repository_triples()
            edm.build_digital_collections_triples()
            edm.build_map_collection_triples()
            edm.build_socscimap_collection_triples()
            edm.build_item_triples()
            sys.stdout.write(str(edm))

        if USE_SSH:
            ftp.close()
    else:
        raise NotImplementedError
